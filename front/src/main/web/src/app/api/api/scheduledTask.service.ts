/**
 * i18n Tool
 * Web API of the i18n tool
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent } from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { Observable } from 'rxjs';

import { ErrorMessagesDto } from '../model/errorMessagesDto';
import { ScheduledTaskDefinitionDto } from '../model/scheduledTaskDefinitionDto';
import { ScheduledTaskDefinitionPatchDto } from '../model/scheduledTaskDefinitionPatchDto';
import { ScheduledTaskExecutionDto } from '../model/scheduledTaskExecutionDto';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable()
export class ScheduledTaskService {
  protected basePath = 'http://127.0.0.1:8080';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

  /**
   * Returns the scheduled task definition having the specified id.
   *
   * @param id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findDefinitionById(
    id: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<ScheduledTaskDefinitionDto>;
  public findDefinitionById(
    id: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<ScheduledTaskDefinitionDto>>;
  public findDefinitionById(
    id: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<ScheduledTaskDefinitionDto>>;
  public findDefinitionById(id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling findDefinitionById.');
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['*/*'];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<ScheduledTaskDefinitionDto>(
      'get',
      `${this.basePath}/api/scheduled-task/${encodeURIComponent(String(id))}/definition`,
      {
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Returns scheduled task definitions.
   *
   * @param enabled Are tasks enabled?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findDefinitions(
    enabled?: boolean,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<Array<ScheduledTaskDefinitionDto>>;
  public findDefinitions(
    enabled?: boolean,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Array<ScheduledTaskDefinitionDto>>>;
  public findDefinitions(
    enabled?: boolean,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Array<ScheduledTaskDefinitionDto>>>;
  public findDefinitions(enabled?: boolean, observe: any = 'body', reportProgress: boolean = false): Observable<any> {
    let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
    if (enabled !== undefined && enabled !== null) {
      queryParameters = queryParameters.set('enabled', <any>enabled);
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['*/*'];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<Array<ScheduledTaskDefinitionDto>>(
      'get',
      `${this.basePath}/api/scheduled-task/definition`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Returns scheduled task executions.
   *
   * @param ascending From the oldest to the newest execution.
   * @param taskDefinitionId Id of the associated task definition
   * @param newerOrEqualThan The maximum age (inclusive) of the execution in EPOCH time (seconds)
   * @param olderOrEqualThan The minimum age (inclusive) of the execution in EPOCH time (seconds)
   * @param status Status to look for
   * @param limit Maximum number of results
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findExecutions(
    ascending?: boolean,
    taskDefinitionId?: string,
    newerOrEqualThan?: number,
    olderOrEqualThan?: number,
    status?: Array<string>,
    limit?: number,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<Array<ScheduledTaskExecutionDto>>;
  public findExecutions(
    ascending?: boolean,
    taskDefinitionId?: string,
    newerOrEqualThan?: number,
    olderOrEqualThan?: number,
    status?: Array<string>,
    limit?: number,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<Array<ScheduledTaskExecutionDto>>>;
  public findExecutions(
    ascending?: boolean,
    taskDefinitionId?: string,
    newerOrEqualThan?: number,
    olderOrEqualThan?: number,
    status?: Array<string>,
    limit?: number,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<Array<ScheduledTaskExecutionDto>>>;
  public findExecutions(
    ascending?: boolean,
    taskDefinitionId?: string,
    newerOrEqualThan?: number,
    olderOrEqualThan?: number,
    status?: Array<string>,
    limit?: number,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
    if (ascending !== undefined && ascending !== null) {
      queryParameters = queryParameters.set('ascending', <any>ascending);
    }
    if (taskDefinitionId !== undefined && taskDefinitionId !== null) {
      queryParameters = queryParameters.set('taskDefinitionId', <any>taskDefinitionId);
    }
    if (newerOrEqualThan !== undefined && newerOrEqualThan !== null) {
      queryParameters = queryParameters.set('newerOrEqualThan', <any>newerOrEqualThan);
    }
    if (olderOrEqualThan !== undefined && olderOrEqualThan !== null) {
      queryParameters = queryParameters.set('olderOrEqualThan', <any>olderOrEqualThan);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters = queryParameters.append('status', <any>element);
      });
    }
    if (limit !== undefined && limit !== null) {
      queryParameters = queryParameters.set('limit', <any>limit);
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['*/*'];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<Array<ScheduledTaskExecutionDto>>(
      'get',
      `${this.basePath}/api/scheduled-task/execution`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Updates a scheduled task definition.
   *
   * @param body
   * @param id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateDefinition(
    body: ScheduledTaskDefinitionPatchDto,
    id: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<ScheduledTaskDefinitionDto>;
  public updateDefinition(
    body: ScheduledTaskDefinitionPatchDto,
    id: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<ScheduledTaskDefinitionDto>>;
  public updateDefinition(
    body: ScheduledTaskDefinitionPatchDto,
    id: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<ScheduledTaskDefinitionDto>>;
  public updateDefinition(
    body: ScheduledTaskDefinitionPatchDto,
    id: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling updateDefinition.');
    }

    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling updateDefinition.');
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['*/*'];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.request<ScheduledTaskDefinitionDto>(
      'patch',
      `${this.basePath}/api/scheduled-task/${encodeURIComponent(String(id))}/definition`,
      {
        body: body,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Enables/Disables the task having the specified id.
   *
   * @param id
   * @param action
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateStatus(
    id: string,
    action?: string,
    observe?: 'body',
    reportProgress?: boolean
  ): Observable<ScheduledTaskDefinitionDto>;
  public updateStatus(
    id: string,
    action?: string,
    observe?: 'response',
    reportProgress?: boolean
  ): Observable<HttpResponse<ScheduledTaskDefinitionDto>>;
  public updateStatus(
    id: string,
    action?: string,
    observe?: 'events',
    reportProgress?: boolean
  ): Observable<HttpEvent<ScheduledTaskDefinitionDto>>;
  public updateStatus(
    id: string,
    action?: string,
    observe: any = 'body',
    reportProgress: boolean = false
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling updateStatus.');
    }

    let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
    if (action !== undefined && action !== null) {
      queryParameters = queryParameters.set('action', <any>action);
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ['*/*'];
    const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = [];

    return this.httpClient.request<ScheduledTaskDefinitionDto>(
      'post',
      `${this.basePath}/api/scheduled-task/${encodeURIComponent(String(id))}/definition`,
      {
        params: queryParameters,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}
